// generated from rosidl_generator_cpp/resource/msg__traits.hpp.template

@#######################################################################
@# EmPy template for generating <msg>__traits.hpp files
@#
@# Context:
@#  - spec (rosidl_parser.MessageSpecification)
@#    Parsed specification of the .msg file
@#  - subfolder (string)
@#    The subfolder / subnamespace of the message
@#    Either 'msg' or 'srv'
@#  - get_header_filename_from_msg_name (function)
@#######################################################################
@
@{
from rosidl_generator_cpp import MSG_TYPE_TO_CPP

cpp_namespace = '%s::%s::' % (spec.base_type.pkg_name, subfolder)

cpp_bounded_types = ['bool', 'char', 'uint8_t', 'int8_t', 'uint16_t', 'int16_t', 'uint32_t', 'int32_t', 'uint64_t', 'int64_t', 'float', 'double']
}@
#include <stdint.h>
#include <array>
#include <string>
#include <vector>

#ifndef __ALL_MSG__BASIC_TEMPLATES
#define __ALL_MSG__BASIC_TEMPLATES

  template<typename T>
  struct has_fixed_size { };

  template<typename T>
  struct has_bounded_size { static const bool value = true; };

  template<typename T>
  struct bounded_size {};

@[for bounded_type in cpp_bounded_types]@
  template<>
  struct has_fixed_size<@(bounded_type)> { static const bool value = true; };

  template<>
  struct bounded_size<@(bounded_type)> { static const size_t value = sizeof(@(bounded_type)); };
@[end for]@

  template<>
  struct has_fixed_size<std::string> { static const bool value = false; };

  template<typename T>
  struct has_fixed_size<std::vector<T>> { static const bool value = false; };

#endif  /* __ALL_MSG__BASIC_TEMPLATES */

#ifndef __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES
#define __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES

#include "@(spec.base_type.pkg_name)/@(subfolder)/@(get_header_filename_from_msg_name(spec.base_type.type))__struct.hpp"

@{
fixed_template_string=""
if not spec.fields:
  fixed_template_string = " true"
else:
    for field in spec.fields:
        if field.type.type == 'string':
            fixed_template_string += " has_fixed_size<std::string>::value &&"
        elif field.type.is_primitive_type():
            fixed_template_string += " has_fixed_size<{}>::value &&".format(MSG_TYPE_TO_CPP[field.type.type])
        else:
            fixed_template_string += " has_fixed_size<{}::msg::{}>::value &&".format(field.type.pkg_name, field.type.type)

    fixed_template_string = fixed_template_string[:len(fixed_template_string)-3]
}@

  template<>
  struct has_fixed_size<@(cpp_namespace)@(spec.base_type.type)> {
    static const bool value =@(fixed_template_string);
  };

@{
bounded_template_string=""
bounded = True

bounded_template_string = ""
if len(spec.fields):
    for field in spec.fields:
        if field.type.type == 'string' and (field.type.string_upper_bound is None):
            bounded = False
            break
        elif field.type.is_array and field.type.array_size is None and (not field.type.is_upper_bound):
            bounded = False
            break

    if not bounded:
      bounded_template_string = "false "
    else:
        for field in spec.fields:
            if field.type.is_primitive_type() and field.type.type != 'string':
              bounded_template_string += "has_bounded_size<{}>::value && ".format(MSG_TYPE_TO_CPP[field.type.type])
            elif not field.type.is_primitive_type():
                bounded_template_string += "has_bounded_size<{}::msg::{}>::value && ".format(field.type.pkg_name, field.type.type)

        bounded_template_string = bounded_template_string[:len(bounded_template_string)-4]

if not len(bounded_template_string):
    bounded_template_string = "true"
}@

  template<>
  struct has_bounded_size<@(cpp_namespace)@(spec.base_type.type)> {
    static const bool value = @(bounded_template_string);
  };

@{
size_template_string = "sizeof({}{})".format(cpp_namespace, spec.base_type.type)
for field in spec.fields:
    if field.type.type == 'string' and (field.type.string_upper_bound is not None):
        size_template_string += "+ {} * sizeof(char) ".format(field.type.string_upper_bound)
    elif field.type.is_array and field.type.array_size is not None and field.type.is_upper_bound:
        if field.type.is_primitive_type():
            typestring = MSG_TYPE_TO_CPP[field.type.type]
        else:
            typestring = "{}::msg::{}".format(field.type.pkg_name, field.type.type)
        size_template_string += "+ {} * sizeof({})".format(field.type.array_size, typestring)
    elif not field.type.is_primitive_type():
        typestring = "{}::msg::{}".format(field.type.pkg_name, field.type.type)
        size_template_string += " + bounded_size<{}>::value - sizeof({})".format(typestring, typestring)
}@

  template<>
  struct bounded_size<@(cpp_namespace)@(spec.base_type.type)>{
    static const size_t value = @(size_template_string);
  };

//////////////////////////////////////



#endif  /* __@(spec.base_type.pkg_name)__@(subfolder)__@(get_header_filename_from_msg_name(spec.base_type.type))__TEMPLATES */
