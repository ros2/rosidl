#include <Python.h>

#include <rosidl_generator_c/message_type_support.h>

@[for spec, subfolder in message_specs]@
@{
type_name = spec.base_type.type
module_name = convert_camel_case_to_lower_case_underscore(type_name)
}@
#include <@(spec.base_type.pkg_name)/@(subfolder)/@(module_name)__type_support.h>
@[end for]@

@[for spec, subfolder in message_specs]@
@{
type_name = spec.base_type.type
module_name = convert_camel_case_to_lower_case_underscore(type_name)
}@
void * @(spec.base_type.pkg_name)_@(module_name)__convert_from_py(PyObject * _pymsg);
PyObject * @(spec.base_type.pkg_name)_@(module_name)__convert_to_py(void * raw_ros_message);
@[end for]@

@{
pymodule_list = []
for spec, subfolder in message_specs:
    type_name = spec.base_type.type
    module_name = convert_camel_case_to_lower_case_underscore(type_name)
    pymodule_list.insert(0, 'pyconvert_from_py_' + module_name)
    pymodule_list.insert(0, 'pyconvert_to_py_' + module_name)
    pymodule_list.insert(0, 'pytype_support_' + module_name)
listlen = len(pymodule_list)
lastobject = ''
}@

static PyMethodDef @(package_name)__methods[] = {
  {NULL, NULL, 0, NULL}  /* sentinel */
};

static struct PyModuleDef @(package_name)__module = {
  PyModuleDef_HEAD_INIT,
  "_@(package_name)_support",
  "_@(package_name)_doc",
  -1,  /* -1 means that the module keeps state in global variables */
  @(package_name)__methods,
  NULL,
  NULL,
  NULL,
  NULL,
};

PyMODINIT_FUNC
PyInit_@(package_name)_s__@(typesupport_impl)(void)
{
  PyObject * m = NULL;
  m = PyModule_Create(&@(package_name)__module);
  if (!m) {
    return NULL;
  }
  int8_t err = 0;
@[for spec, subfolder in message_specs]@
@{
type_name = spec.base_type.type
module_name = convert_camel_case_to_lower_case_underscore(type_name)
}@
  PyObject * pyconvert_from_py_@(module_name) = NULL;

  pyconvert_from_py_@(module_name) = PyCapsule_New(
    (void *)&@(spec.base_type.pkg_name)_@(module_name)__convert_from_py,
    NULL, NULL);
  if (NULL == pyconvert_from_py_@(module_name)) {
    goto fail_@(lastobject);
  }
@{
lastobject = 'pyconvert_from_py_' + module_name    
}@
  err = PyModule_AddObject(m, "convert_from_py_@(module_name)", pyconvert_from_py_@(module_name));
  if (err) {
    goto fail_@(lastobject);
  }

  PyObject * pyconvert_to_py_@(module_name) = NULL;
  pyconvert_to_py_@(module_name) = PyCapsule_New(
    (void *)&@(spec.base_type.pkg_name)_@(module_name)__convert_to_py,
    NULL, NULL);
  if (NULL == pyconvert_to_py_@(module_name)) {
    goto fail_@(lastobject);
  }
@{
lastobject = 'pyconvert_to_py_' + module_name    
}@
  err = PyModule_AddObject(m, "convert_to_py_@(module_name)", pyconvert_to_py_@(module_name));
  if (err) {
    goto fail_@(lastobject);
  }
  PyObject * pytype_support_@(module_name) = NULL;
  pytype_support_@(module_name) = PyCapsule_New(
    (void *)ROSIDL_GET_TYPE_SUPPORT(@(spec.base_type.pkg_name), @(subfolder), @(spec.msg_name)),
    NULL, NULL);
  if (NULL == pytype_support_@(module_name)) {
    goto fail_@(lastobject);
  }
@{
lastobject = 'pytype_support_' + module_name    
}@
  err = PyModule_AddObject(m, "type_support_@(module_name)", pytype_support_@(module_name));
  if (err) {
    goto fail_@(lastobject);
  }

@[end for]@
  return m;

@[for i in range(listlen)]@
@[  if i != listlen - 1]@
fail_@(pymodule_list[i]):
  Py_XDECREF(@(pymodule_list[i]));
  @(pymodule_list[i]) = NULL;
@[  else]@
fail_@(pymodule_list[i]):
fail_:
  Py_XDECREF(m);
  return NULL;
@[  end if]@
@[end for]@
}
